# DLOB Architecture

The **DLOB** (Decentralized Limit Order Book) is Drift's offchain order book that aggregates all resting limit orders across user accounts. It provides a unified orderbook view for matching and price discovery while keeping order storage onchain.

## Why offchain?

Storing a sorted orderbook onchain would be prohibitively expensive. Instead, Drift stores orders in user accounts (up to 32 per user), and the DLOB server:
1. Scans all user accounts
2. Extracts resting limit orders
3. Sorts them by price into a bid/ask orderbook
4. Serves this orderbook via websocket and HTTP

This gives you Binance-style orderbook depth without onchain sorting costs.

## DLOB server responsibilities

The DLOB server (https://dlob.drift.trade) maintains:

**Orderbook state**:
- Bids sorted descending by price
- Asks sorted ascending by price
- Grouped by price levels
- Market depth aggregation

**Order filtering**:
- Excludes expired orders
- Filters by market (SOL-PERP, BTC-PERP, etc.)
- Handles post-only and reduce-only flags
- Shows only valid, fillable orders

**Real-time updates**:
- Subscribes to UserAccount changes via Solana RPC
- Updates orderbook when orders are placed/canceled/filled
- Publishes updates via websocket

## Order lifecycle through DLOB

1. **User places limit order** → onchain UserAccount updated
2. **DLOB detects new order** → scans UserAccount via RPC subscription
3. **Order added to DLOB** → inserted at correct price level in sorted orderbook
4. **Orderbook update broadcast** → websocket clients receive new depth
5. **Order fills** → UserAccount marked filled, DLOB removes order
6. **Orderbook update broadcast** → clients see reduced depth

The DLOB never modifies onchain state, it's read-only. All fills happen onchain via the Drift program.

## DLOB vs onchain state

**onchain (source of truth)**:
- Orders stored in UserAccount
- Fills processed by Drift program
- Settlement and PnL calculation
- Collateral and margin checks

**DLOB (aggregated view)**:
- Sorted orderbook for matching
- Depth aggregation
- Real-time orderbook updates
- Convenient API for UIs and bots

If DLOB goes down, orders are still onchain and valid, they just won't be visible in the aggregated orderbook until DLOB recovers.

## Accessing the DLOB

**WebSocket** (for real-time updates):
```typescript
const ws = new WebSocket("wss://dlob.drift.trade/ws");
ws.send(JSON.stringify({
  type: "subscribe",
  channel: "orderbook",
  marketType: "perp",
  market: "SOL-PERP",
  grouping: 10
}));
```

**HTTP API** (for snapshots):
```typescript
const orderbook = await fetch(
  "https://dlob.drift.trade/orderbook?marketType=perp&marketIndex=0"
).then(r => r.json());
```

**SDK DLOB class** (for local orderbook building):
```typescript
import { DLOB } from "@drift-labs/sdk";

const dlob = new DLOB();
// Add orders from user accounts
dlob.insertOrder(order, userAccount, slot);
// Get best bid/ask
const bestBid = dlob.getBestBid(marketIndex);
```

## JIT auction integration

When a taker order arrives (market order or aggressive limit), it enters a JIT auction before hitting the DLOB. Market makers can compete to fill it at better prices during the auction period (typically 5-10 slots). After the auction:

1. If no JIT makers filled it → match against DLOB
2. If partially filled by JIT → remaining size matches DLOB
3. If fully filled by JIT → no DLOB interaction

The DLOB provides the "default" liquidity if JIT makers don't participate.

## Indicative quotes

The DLOB also tracks **indicative quotes**, offchain quotes from market makers that aren't real onchain orders but show intent to provide liquidity at certain prices. These help with price discovery but can't be executed against. UI typically shows them separately or with an "indicative" tag.

## Performance characteristics

- **Latency**: DLOB updates within 1-2 seconds of onchain order placement (depends on RPC)
- **Depth**: Aggregates thousands of orders across hundreds of users
- **Uptime**: Redundant DLOB servers ensure high availability
- **WebSocket**: Handles thousands of concurrent connections

For low-latency bots, subscribing directly to onchain UserAccounts (via RPC or gRPC) can be faster than waiting for DLOB updates.

## Related

- [JIT Auctions](./jit-auctions) - How JIT fits before DLOB matching
- [Matching Engine](./matching-engine) - Full liquidity priority flow
- [Orderbook + WebSocket](/developers/ecosystem-builders/orderbook-and-ws) - Using DLOB in your app
