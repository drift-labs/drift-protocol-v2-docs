# Bot Template

This is a complete, runnable “starting point” for a Drift trading bot. Customize the strategy section and replace placeholders/env vars for your deployment.

### Template

```ts
/**
 * Drift Protocol Trading Bot Template
 *
 * Customize the strategy in the `executeStrategy` function.
 */

import { Connection, Keypair } from "@solana/web3.js";
import { Wallet } from "@coral-xyz/anchor";
import * as fs from "fs";
import * as dotenv from "dotenv";

import {
  BN,
  BASE_PRECISION,
  BulkAccountLoader,
  DriftClient,
  DriftEnv,
  MarketType,
  MARGIN_PRECISION,
  OrderType,
  PositionDirection,
  PostOnlyParams,
  PRICE_PRECISION,
  QUOTE_PRECISION,
  convertToNumber,
  initialize,
} from "@drift-labs/sdk";

dotenv.config();

const CONFIG = {
  RPC_URL: process.env.RPC_URL || "https://api.mainnet-beta.solana.com",
  ENV: (process.env.DRIFT_ENV || "mainnet-beta") as DriftEnv,
  KEYPAIR_PATH: process.env.KEYPAIR_PATH || "./keypair.json",
  MARKET_INDEX: Number(process.env.MARKET_INDEX || 0),
  LOOP_INTERVAL_MS: Number(process.env.LOOP_INTERVAL_MS || 5000),
  SPREAD_BPS: Number(process.env.SPREAD_BPS || 10),
  MAX_POSITION_SIZE: Number(process.env.MAX_POSITION_SIZE || 10),
  DEFAULT_ORDER_SIZE: Number(process.env.DEFAULT_ORDER_SIZE || 1),
  MAX_LEVERAGE: Number(process.env.MAX_LEVERAGE || 3),
  MIN_FREE_COLLATERAL: Number(process.env.MIN_FREE_COLLATERAL || 100),
};

function log(...args: any[]) {
  console.log(new Date().toISOString(), ...args);
}

async function setupDriftClient(): Promise<DriftClient> {
  const secretKey = JSON.parse(fs.readFileSync(CONFIG.KEYPAIR_PATH, "utf-8"));
  const keypair = Keypair.fromSecretKey(Uint8Array.from(secretKey));
  const wallet = new Wallet(keypair);

  const connection = new Connection(CONFIG.RPC_URL, "confirmed");

  initialize({ env: CONFIG.ENV });

  const accountLoader = new BulkAccountLoader(connection, "confirmed", 1000);
  const driftClient = new DriftClient({
    connection,
    wallet,
    env: CONFIG.ENV,
    accountSubscription: {
      type: "polling",
      accountLoader,
    },
  });

  const ok = await driftClient.subscribe();
  if (!ok) throw new Error("Failed to subscribe to DriftClient");
  return driftClient;
}

function getMarketData(driftClient: DriftClient) {
  const oracleData = driftClient.getOracleDataForPerpMarket(CONFIG.MARKET_INDEX);
  const oraclePrice = convertToNumber(oracleData.price, PRICE_PRECISION);
  const halfSpread = (oraclePrice * (CONFIG.SPREAD_BPS / 10000)) / 2;
  return {
    oraclePrice,
    bidPrice: oraclePrice - halfSpread,
    askPrice: oraclePrice + halfSpread,
  };
}

function getAccountData(user: any) {
  const freeCollateral = convertToNumber(user.getFreeCollateral(), QUOTE_PRECISION);
  const leverage = convertToNumber(user.getLeverage(), MARGIN_PRECISION);
  const health = user.getHealth();
  const perpPosition = user.getPerpPosition(CONFIG.MARKET_INDEX);
  const positionSize = perpPosition ? convertToNumber(perpPosition.baseAssetAmount, BASE_PRECISION) : 0;
  const unrealizedPnl = convertToNumber(user.getUnrealizedPNL(false, CONFIG.MARKET_INDEX), QUOTE_PRECISION);
  return { freeCollateral, leverage, health, positionSize, unrealizedPnl };
}

function canTrade(a: { freeCollateral: number; leverage: number; health: number; positionSize: number }) {
  if (a.freeCollateral < CONFIG.MIN_FREE_COLLATERAL) return false;
  if (a.leverage > CONFIG.MAX_LEVERAGE) return false;
  if (Math.abs(a.positionSize) >= CONFIG.MAX_POSITION_SIZE) return false;
  if (a.health < 20) return false;
  return true;
}

async function placeOrder(driftClient: DriftClient, direction: PositionDirection, size: number, price: number) {
  const orderParams: any = {
    orderType: OrderType.LIMIT,
    marketIndex: CONFIG.MARKET_INDEX,
    direction,
    baseAssetAmount: driftClient.convertToPerpPrecision(size),
    price: driftClient.convertToPricePrecision(price),
    postOnly: PostOnlyParams.TRY_POST_ONLY,
  };

  return await driftClient.placePerpOrder(orderParams);
}

async function cancelAllOrders(driftClient: DriftClient) {
  await driftClient.cancelOrders(MarketType.PERP, CONFIG.MARKET_INDEX);
}

async function main() {
  const driftClient = await setupDriftClient();
  const user = driftClient.getUser();

  if (!(await user.exists())) {
    throw new Error("User account does not exist. Initialize it first.");
  }

  while (true) {
    await driftClient.fetchAccounts();

    const market = getMarketData(driftClient);
    const acct = getAccountData(user);

    log("status", {
      oraclePrice: market.oraclePrice,
      position: acct.positionSize,
      pnl: acct.unrealizedPnl,
      health: acct.health,
      leverage: acct.leverage,
      freeCollateral: acct.freeCollateral,
    });

    if (!canTrade(acct)) {
      await new Promise((r) => setTimeout(r, CONFIG.LOOP_INTERVAL_MS));
      continue;
    }

    await cancelAllOrders(driftClient);

    const remaining = CONFIG.MAX_POSITION_SIZE - Math.abs(acct.positionSize);
    const size = Math.min(CONFIG.DEFAULT_ORDER_SIZE, remaining);
    if (size <= 0) continue;

    const bidPrice = market.oraclePrice * (1 - CONFIG.SPREAD_BPS / 10000);
    const askPrice = market.oraclePrice * (1 + CONFIG.SPREAD_BPS / 10000);

    await placeOrder(driftClient, PositionDirection.LONG, size, bidPrice);
    await placeOrder(driftClient, PositionDirection.SHORT, size, askPrice);

    await new Promise((r) => setTimeout(r, CONFIG.LOOP_INTERVAL_MS));
  }
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
```

