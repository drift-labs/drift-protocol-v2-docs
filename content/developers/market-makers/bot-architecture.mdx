# Bot Architecture Patterns

These patterns are used across keeper-bots (market making, fillers, triggers), and can potentially be useful to copy.

### Subscription loop + resubscribe

```js
const orderSubscriber = new OrderSubscriber({
  driftClient,
  subscriptionConfig: {
    type: "websocket",
    resubTimeoutMs: 30_000,
    resyncIntervalMs: 300_000,
  },
});
await orderSubscriber.subscribe();
```

### Periodic tasks + mutex guard

```js
if (await tryAcquire(periodicTaskMutex)) {
  try {
    // refresh quotes, run risk checks, rebalance
  } finally {
    // update watchdog timestamp
  }
}
```

### Throttling / backoff

```js
const lastAttempt = throttledNodes.get(nodeKey) ?? 0;
if (lastAttempt + 1000 > Date.now()) return;
throttledNodes.set(nodeKey, Date.now());
```

### Priority fees and tx sending

```js
const priorityFee = priorityFeeSubscriber.getCustomStrategyResult();
const ix = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: Math.floor(priorityFee * driftClient.txSender.getSuggestedPriorityFeeMultiplier()),
});
```

### ALT and blockhash lifecycle

```js
const lookupTableAccounts = await driftClient.fetchAllLookupTableAccounts();
const { blockhash } = await driftClient.connection.getLatestBlockhash({
  commitment: "confirmed",
});
```

## Risk and filtering

For JIT and SWIFT flows, apply these filters before filling to avoid adverse selection and stay within risk limits.

**Oracle validation** — Reject if oracle is stale or confidence is too wide:

```js
const oracle = driftClient.getMMOracleDataForPerpMarket(marketIndex);
if (!oracle.isValid) return;
if (oracle.confidence > maxConfidence) return;
```

**Position limits** — Don't fill if it would exceed your max position or leverage:

```js
const currentPosition = userAccount.perpPositions[marketIndex];
const newPosition = currentPosition.baseAssetAmount + fillSize;
if (Math.abs(newPosition) > maxPositionSize) return;
```

**Toxic flow** — Skip orders that increase risk (e.g. direction that worsens your inventory) and skip when oracle/index divergence is high:

```js
if (isRiskIncreasing(order, currentPosition)) return;
if (Math.abs(oraclePrice - indexPrice) > maxDivergence) return;
```

When subscribed to both SWIFT and onchain feeds, use `isSignedMsgOrder(order)` to avoid double-handling the same order. See [SWIFT API](./swift-api#detecting-swift-orders-in-onchain-feeds) for details.
